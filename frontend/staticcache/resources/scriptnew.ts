/**
 * Elephancy backend (Simple)
 * Elephancy backend (Simple)
 *
 * OpenAPI spec version: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// adapted by S. Riha

// import * as request from 'request';
// import * as http from 'http';
// import * as Promise from 'bluebird';
// import request = require('request');
// import http = require('http');
// import Promise = require('bluebird');

let defaultBasePath = 'http://127.0.0.1:8088/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class ErrorModel {
    'code': number;
    'message': string;
}

export class Links {
    'self': string;
}

export class Page {
    'id': number;
    'links': Links;
    'prettyurl': string;
    'linkname': string;
    'linkweight': string;
    'metatitle': string;
}


// export interface Authentication {
//     /**
//     * Apply authentication settings to header and query params.
//     */
//     applyToRequest(requestOptions: request.Options): void;
// }

// export class HttpBasicAuth implements Authentication {
//     public username: string;
//     public password: string;
//     applyToRequest(requestOptions: request.Options): void {
//         requestOptions.auth = {
//             username: this.username, password: this.password
//         }
//     }
// }

// export class ApiKeyAuth implements Authentication {
//     public apiKey: string;

//     constructor(private location: string, private paramName: string) {
//     }

//     applyToRequest(requestOptions: request.Options): void {
//         if (this.location == "query") {
//             (<any>requestOptions.qs)[this.paramName] = this.apiKey;
//         } else if (this.location == "header") {
//             requestOptions.headers[this.paramName] = this.apiKey;
//         }
//     }
// }

// export class OAuth implements Authentication {
//     public accessToken: string;

//     applyToRequest(requestOptions: request.Options): void {
//         requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
//     }
// }

// export class VoidAuth implements Authentication {
//     public username: string;
//     public password: string;
//     applyToRequest(requestOptions: request.Options): void {
//         // Do nothing
//     }
// }

// export enum DefaultApiApiKeys {
// }

export class DefaultApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    // protected authentications = {
    //     'default': <Authentication>new VoidAuth(),
    // }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    // set useQuerystring(value: boolean) {
    //     this._useQuerystring = value;
    // }

    // public setApiKey(key: DefaultApiApiKeys, value: string) {
    //     this.authentications[DefaultApiApiKeys[key]].apiKey = value;
    // }
    // private extendObj<T1,T2>(objA: T1, objB: T2) {
    //     for(let key in objB){
    //         if(objB.hasOwnProperty(key)){
    //             objA[key] = objB[key];
    //         }
    //     }
    //     return <T1&T2>objA;
    // }
    private extendObj<T1,T2 extends T1>(objA:T2, objB: T2): T1|T2 {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return objA;
    }
    // /**
    //  * 
    //  * Find page by key-value pair
    //  * @param key Page property
    //  */
    // public findPageByKeyValue (key: string) : Promise<{ response: http.ClientResponse; body: Page;  }> {
    //     const localVarPath = this.basePath + '/pages/FindPageByKeyValue';
    //     let queryParameters: any = {};
    //     let headerParams: any = this.extendObj({}, this.defaultHeaders);
    //     let formParams: any = {};


    //     // verify required parameter 'key' is not null or undefined
    //     if (key === null || key === undefined) {
    //         throw new Error('Required parameter key was null or undefined when calling findPageByKeyValue.');
    //     }

    //     if (key !== undefined) {
    //         queryParameters['key'] = key;
    //     }

    //     let useFormData = false;

    //     // let requestOptions: request.Options = {
    //     //     method: 'GET',
    //     //     qs: queryParameters,
    //     //     headers: headerParams,
    //     //     uri: localVarPath,
    //     //     useQuerystring: this._useQuerystring,
    //     //     json: true,
    //     // };

    //     // this.authentications.default.applyToRequest(requestOptions);

    //     // if (Object.keys(formParams).length) {
    //     //     if (useFormData) {
    //     //         (<any>requestOptions).formData = formParams;
    //     //     } else {
    //     //         requestOptions.form = formParams;
    //     //     }
    //     // }
    //     return new Promise<{ response: http.ClientResponse; body: Page;  }>((resolve, reject) => {
    //         request(requestOptions, (error, response, body) => {
    //             if (error) {
    //                 reject(error);
    //             } else {
    //                 if (response.statusCode >= 200 && response.statusCode <= 299) {
    //                     resolve({ response: response, body: body });
    //                 } else {
    //                     reject({ response: response, body: body });
    //                 }
    //             }
    //         });
    //     });
    // }
    /**
     * 
     * Returns all pages
     */
    public listPages () : Promise<{ response: any; body: Array<Page>;  }> {
        const localVarPath = this.basePath + '/pages';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        // let requestOptions: request.Options = {
        //     method: 'GET',
        //     qs: queryParameters,
        //     headers: headerParams,
        //     uri: localVarPath,
        //     useQuerystring: this._useQuerystring,
        //     json: true,
        // };

        // this.authentications.default.applyToRequest(requestOptions);

        // if (Object.keys(formParams).length) {
        //     if (useFormData) {
        //         (<any>requestOptions).formData = formParams;
        //     } else {
        //         requestOptions.form = formParams;
        //     }
        // }
        
        return new Promise<{ response: any; body: Array<Page>;  }>((resolve, reject) => {
        // Do the usual XHR stuff
            var req = new XMLHttpRequest();
            req.open('GET', localVarPath);

            req.onload = function() {
            // This is called even on 404 etc
            // so check the status
            if (req.status == 200) {
                // Resolve the promise with the response text
                resolve(req.response);
            }
            else {
                // Otherwise reject with the status text
                // which will hopefully be a meaningful error
                reject(Error(req.statusText));
            }
            };

            // Handle network errors
            req.onerror = function() {
            reject(Error("Network Error"));
            };

            // Make the request
            req.send();
        });
    }
}
