/*
 * Elephancy backend (Simple)
 *
 * Elephancy backend (Simple)
 *
 * OpenAPI spec version: 0.1.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package frontendserver

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	jc "mystuff/elephancy/jsoncommon"
	"net/url"
)

/**
 *
 * Returns all pages
 *
 * @return []Page
 */

var basepath = "http://127.0.0.1:8088/api"

// ListPages lists pages
func ListPages() (jc.Pages, error) {
	var httpMethod = "GET"
	// create path and map variables
	path := basepath + "/pages"
	var successPayload = new([]jc.Page)
	httpResponse, err := callAPI(path, httpMethod, url.Values{})
	if err != nil {
		return *successPayload, err
	}
	defer httpResponse.Body.Close()
	var b bytes.Buffer
	_, err = b.ReadFrom(httpResponse.Body)
	if err != nil {
		log.Fatal(err)

	}
	err = json.Unmarshal(b.Bytes(), &successPayload)
	return *successPayload, err
}

// // FindPageByPrettyURL returns page ID
// func FindPageByPrettyURL(prettyurl string) (jc.Page, error) {
// 	var httpMethod = "GET"
// 	// create path and map variables
// 	path := basepath + "/pages/FindPageByPrettyURL"

// 	var successPayload = new(jc.Page)
// 	v := url.Values{}
// 	v.Set("prettyurl", prettyurl)
// 	httpResponse, err := callAPI(path, httpMethod, v)
// 	if err != nil {
// 		return *successPayload, err
// 	}
// 	defer httpResponse.Body.Close()
// 	if httpResponse.StatusCode == 404 {
// 		return *successPayload, fmt.Errorf("Page not found")
// 	}
// 	var b bytes.Buffer
// 	_, err = b.ReadFrom(httpResponse.Body)
// 	if err != nil {
// 		log.Fatal(err)

// 	}
// 	err = json.Unmarshal(b.Bytes(), &successPayload)
// 	return *successPayload, err
// }

// func FindPageByLinksSelf(link string) (jc.Page, error) {
// 	var httpMethod = "GET"
// 	// create path and map variables
// 	path := basepath + "/pages/FindPageByLinksSelf"
// 	println("****BELLO")
// 	var successPayload = new(jc.Page)
// 	v := url.Values{}
// 	v.Set("prettyurl", link)
// 	httpResponse, err := callAPI(path, httpMethod, v)
// 	if err != nil {
// 		return *successPayload, err
// 	}
// 	defer httpResponse.Body.Close()
// 	if httpResponse.StatusCode == 404 {
// 		return *successPayload, fmt.Errorf("Page not found")
// 	}
// 	var b bytes.Buffer
// 	_, err = b.ReadFrom(httpResponse.Body)
// 	if err != nil {
// 		log.Fatal(err)

// 	}
// 	err = json.Unmarshal(b.Bytes(), &successPayload)
// 	return *successPayload, err
// }

func FindPageByKeyValue(key string, value string) (jc.Page, error) {
	var httpMethod = "GET"
	// create path and map variables
	path := basepath + "/pages/FindPageByKeyValue"
	var successPayload = new(jc.Page)
	v := url.Values{}
	v.Set("key", key)
	v.Add("value", value)
	httpResponse, err := callAPI(path, httpMethod, v)
	if err != nil {
		return *successPayload, err
	}
	defer httpResponse.Body.Close()
	if httpResponse.StatusCode == 404 {
		return *successPayload, fmt.Errorf("Page not found")
	}
	var b bytes.Buffer
	_, err = b.ReadFrom(httpResponse.Body)
	if err != nil {
		log.Fatal(err)

	}
	err = json.Unmarshal(b.Bytes(), &successPayload)
	return *successPayload, err
}

// func ContentServer(w http.ResponseWriter, r *http.Request) {
// 	// No caching policy here. Must be handled by frontend.
// 	http.FileServer(http.Dir("./")).ServeHTTP(w, r)
// }
